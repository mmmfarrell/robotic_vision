//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <opencv2/core/core.hpp>
#include "opencv2/features2d.hpp"
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
using namespace cv;
using namespace std;
// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);

// Setup SimpleBlobDetector parameters.
SimpleBlobDetector::Params params;
Ptr<SimpleBlobDetector> detector;

// Select rectangle stuff
Mat image;
bool selectObject = false;
int trackObject = 0;
Point origin;
Rect selection, trackWindow;
Mat mask;

// Kalman filter stuff
KalmanFilter KF(4, 2, 0);
Mat state(4, 1, CV_32F);
Mat processNoise(4, 1, CV_32F);
Mat measurement = Mat::zeros(2, 1, CV_32F);

// User draws box around object to track. This triggers CAMShift to start tracking
static void onMouse( int event, int x, int y, int, void* )
{
    if( selectObject )
    {
        selection.x = MIN(x, origin.x);
        selection.y = MIN(y, origin.y);
        selection.width = std::abs(x - origin.x);
        selection.height = std::abs(y - origin.y);

        selection &= Rect(0, 0, image.cols, image.rows);
    }

    switch( event )
    {
    case EVENT_LBUTTONDOWN:
        origin = Point(x,y);
        selection = Rect(x,y,0,0);
        selectObject = true;
        break;
    case EVENT_LBUTTONUP:
        selectObject = false;
        if( selection.width > 0 && selection.height > 0 )
            trackObject = -1;   // Set up CAMShift properties in main() loop
        break;
    }
}
 
int main(int argc, char* argv[])
{
  
  //// Change thresholds
  params.minThreshold = 0;
  params.maxThreshold = 255;
   
  // Filter by Area.
  params.filterByArea = true;
  params.minArea = 300;
   
  // Filter by Circularity
  params.filterByCircularity = false;
  params.minCircularity = 0.1;
   
  // Filter by Convexity
  params.filterByConvexity = false;
  params.minConvexity = 0.87;
   
  // Filter by Inertia
  params.filterByInertia = false;
  params.minInertiaRatio = 0.01;

  // Set up the detector with default parameters.
  //SimpleBlobDetector detector;
  detector = SimpleBlobDetector::create(params);

  // Kalman Filter
  double dt = 1./30.0f;
  KF.transitionMatrix = (Mat_<float>(4,4) << 1, 0, dt, 0, 0, 1, 0, dt, 0, 0, 1, 0, 0, 0, 0, 1);
  setIdentity(KF.measurementMatrix);
  setIdentity(KF.processNoiseCov, Scalar::all(1e-3));
  setIdentity(KF.measurementNoiseCov, Scalar::all(1e-1));
  setIdentity(KF.errorCovPost, Scalar::all(1));

  cout << "transitionMatrix\n" << KF.transitionMatrix << endl;
  cout << "measurementMatrix\n" << KF.measurementMatrix<< endl;
  cout << "processNoiseCov\n" << KF.processNoiseCov<< endl;
  cout << "measurementNoiseCov\n" << KF.measurementNoiseCov<< endl;

    //create GUI windows
    namedWindow("Frame");
    //namedWindow("FG Mask MOG 2");

    setMouseCallback("Frame", onMouse);
    
    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
    processVideo("mv2_001.avi");
    
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
    //create the capture object
    VideoCapture capture(videoFilename);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }
    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        frame.copyTo(image);
        //update the background model
        pMOG2->apply(frame, fgMaskMOG2);
        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << capture.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

        // Erode and dilate
        int erosion_size = 1;
        Mat element = getStructuringElement( MORPH_RECT, 
                                Size( 2*erosion_size + 1, 2*erosion_size + 1),
                                Point( erosion_size, erosion_size) );
        Mat erosion_dst, erode2;
        erode( fgMaskMOG2, erosion_dst, element);
        erode( erosion_dst, erode2, element);

        Mat output;
        dilate(erosion_dst, output, element);
        dilate(output, output, element);

        //cout << " Track Obj: " << trackObject << endl;
        if (trackObject < 0)
        {

          trackWindow = selection;
          cout << "track window x " << trackWindow.x << ", y " << trackWindow.y << endl;
          trackObject = 1;

          KF.statePost.at<float>(0) = selection.x + selection.width/2.;
          KF.statePost.at<float>(1) = selection.y + selection.height/2.;
          KF.statePost.at<float>(2) = 0.;
          KF.statePost.at<float>(3) = 0.;

          cout << "State post: \n" << KF.statePost << endl;
        }
        else if (trackObject == 1)
        {
          Mat maskroi(output, trackWindow);
          
          std::vector<KeyPoint> keypoints;
          Mat inverted;
          bitwise_not(maskroi, inverted);
          detector->detect(inverted, keypoints);

          vector<KeyPoint>::const_iterator it = keypoints.begin(), end = keypoints.end();
          double MeasX(0), MeasY(0);
          double num_points = keypoints.size();

          // Kalman Filter stuff
          KF.predict();
          if (num_points != 0)
          {
            //for ( ; it != end; ++it )
            //{
              ////cout << "x " << it->pt.x <<", y " << it->pt.y << endl;
              //MeasX += it->pt.x;
              //MeasY += it->pt.y;

              //it->pt.x += trackWindow.x;
              //it->pt.y += trackWindow.y;
            //}
            for (int i = 0; i < num_points; i++)
            {
              MeasX += keypoints[i].pt.x;
              MeasY += keypoints[i].pt.y;
              keypoints[i].pt.x += trackWindow.x;
              keypoints[i].pt.y += trackWindow.y;

            }
            MeasX /= num_points;
            MeasY /= num_points;
            cout << "x " << MeasX << ", y " << MeasY << endl;

            //double diffx, diffy;
            //diffx = MeasX - ( trackWindow.width/2.);
            //diffy = MeasY - (trackWindow.height/2.);
            //cout << "Diff x " << diffx << ", y " << diffy << endl;
            //trackWindow.x += diffx;
            //trackWindow.y += diffy;
            ////trackWindow.x = trackWindow.x + diffx;
            ////trackWindow.y = trackWindow.y + diffy;

            //cout << "track window x " << trackWindow.x << ", y " << trackWindow.y << endl;


            drawKeypoints( frame, keypoints, frame, Scalar(0, 0, 255), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);

            // Kalman Filter update
            measurement.at<float>(0) = MeasX + trackWindow.x;
            measurement.at<float>(1) = MeasY + trackWindow.y;
            KF.correct(measurement);

            Point meas(MeasX + trackWindow.x, MeasY + trackWindow.y);
            circle(frame, meas, 3, Scalar(0, 255, 0), -1);

          }

          // Update track window with kalman estimate as center
          Point estimate(KF.statePost.at<float>(0), KF.statePost.at<float>(1));
          double diffx, diffy;
          diffx = estimate.x - trackWindow.x - ( trackWindow.width/2.);
          diffy = estimate.y - trackWindow.y - (trackWindow.height/2.);
          cout << "Diff x " << diffx << ", y " << diffy << endl;
          trackWindow.x += diffx;
          trackWindow.y += diffy;
          //trackWindow.x = trackWindow.x + diffx;
          //trackWindow.y = trackWindow.y + diffy;

          cout << "track window x " << trackWindow.x << ", y " << trackWindow.y << endl;

          Mat tracker;
          output.copyTo(tracker);
          rectangle( frame, trackWindow, Scalar(0, 255, 0), 3);
          cout << "Draw green rect" << endl;
          cout << "track window x " << trackWindow.x << ", y " << trackWindow.y << endl;

          circle (frame, estimate, 3, Scalar(255, 0, 0), -1);
          //imshow("tracker", tracker);
        }


        
        //show the current frame and the fg masks
        imshow("Frame", frame);
        //imshow("FG Mask MOG 2", fgMaskMOG2);
        imshow("Eroded Mask", output);
        Mat bgImage;
        pMOG2->getBackgroundImage(bgImage);
        //imshow("BG Image", bgImage);

        //get the input from the keyboard
        keyboard = waitKey( 30 );
    }
    //delete capture object
    capture.release();
}
